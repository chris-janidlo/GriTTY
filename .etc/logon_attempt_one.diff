attempt at making a working logon shell and working command segmentation (ie, diff commands for logon and fight)
serious bugs and pretty garbo but something I want to keep for reference/in case I want to use something from it
diff --git a/BaseCommands.lua b/BaseCommands.lua
index 9804154..d46e025 100644
--- a/BaseCommands.lua
+++ b/BaseCommands.lua
@@ -1,5 +1,9 @@
 local Signal = require 'hump.signal'
 local PointField = require 'DataStructures.StaticIntPointField'
+local Gamestate = require 'hump.gamestate'
+local Timer = require 'hump.timer'
+local CombatState = require 'CombatState'
+local LogonShell = require 'LogonShell'
 
 ---------- COMMAND FORMAT ----------
 -- table with following values
@@ -8,78 +12,4 @@ local PointField = require 'DataStructures.StaticIntPointField'
 -- helpString: printed when 'help' command is run
 -- isPlayer: set to true if actionFun acts on a Player
 
-local function move(name, point)
-	return {
-		name = name,
-		actionFun = function(wait, player)
-			player:setColor(player.actingColor)
-			wait(.15)
-			player.location = player.location + point
-			wait(.2)
-			player:setColor()
-		end,
-		helpString = 'move one tile',
-		isPlayer = true
-	}
-end
-
-local function dodge(name, direction)
-	return {
-		name = name,
-		actionFun = function(wait, player)
-			player:setColor(player.actingColor)
-			wait(.15)
-
-			player.invuln = true; player:setIndicator('.')
-			player.location = player.location + direction * 2
-			wait(.25)
-			
-			player.location = player.location + direction
-			player:resetIndicator()
-			wait(.5)
-
-			player.invuln = false; player:setColor()
-		end,
-		helpString = 'move three tiles while invincible',
-		isPlayer = true
-	}
-end
-
--- expansions
-local e = {
-	-- wasd
-	w = PointField(0, -1),
-	a = PointField(-1, 0),
-	s = PointField(0, 1),
-	d = PointField(1, 0)
-}
-
-local cmds = {}
-
-cmds.w = move('w', e.w)
-cmds.a = move('a', e.a)
-cmds.s = move('s', e.s)
-cmds.d = move('d', e.d)
-
-cmds.ww = dodge('ww', e.w)
-cmds.aa = dodge('aa', e.a)
-cmds.ss = dodge('ss', e.s)
-cmds.dd = dodge('dd', e.d)
-
-cmds.help = {
-	name = 'help',
-	actionFun = function()
-		print('GriTTY version 1.37')
-		local order = {}
-		for s, cmd in pairs(cmds) do
-			table.insert(order, s..':\t'..cmd.helpString)
-		end
-		table.sort(order)
-		for i,s in ipairs(order) do
-			Signal.emit('tty_stdout', s)
-		end
-	end,
-	helpString = 'print this message'
-}
-
 return cmds
diff --git a/CombatState.lua b/CombatState.lua
index e904a46..839f57a 100644
--- a/CombatState.lua
+++ b/CombatState.lua
@@ -3,33 +3,93 @@
 local Terminal = require 'Terminal'
 local CombatArena = require 'CombatArena'
 local Vector = require 'hump.vector'
+local PointField = require 'DataStructures.StaticIntPointField'
 
 local CombatState = {}
 
+local function move(name, point)
+	return {
+		name = name,
+		actionFun = function(wait, player)
+			player:setColor(player.actingColor)
+			wait(.15)
+			player.location = player.location + point
+			wait(.2)
+			player:setColor()
+		end,
+		helpString = 'move one tile'
+	}
+end
+
+local function dodge(name, direction)
+	return {
+		name = name,
+		actionFun = function(wait, player)
+			player:setColor(player.actingColor)
+			wait(.15)
+
+			player.invuln = true; player:setIndicator('.')
+			player.location = player.location + direction * 2
+			wait(.25)
+			
+			player.location = player.location + direction
+			player:resetIndicator()
+			wait(.5)
+
+			player.invuln = false; player:setColor()
+		end,
+		helpString = 'move three tiles while invincible'
+	}
+end
+
+local e = {
+	-- wasd
+	w = PointField(0, -1),
+	a = PointField(-1, 0),
+	s = PointField(0, 1),
+	d = PointField(1, 0)
+}
+
+local cmds = {
+	w = move('w', e.w),
+	a = move('a', e.a),
+	s = move('s', e.s),
+	d = move('d', e.d),
+
+	ww = dodge('ww', e.w),
+	aa = dodge('aa', e.a),
+	ss = dodge('ss', e.s),
+	dd = dodge('dd', e.d)
+}
+
 function CombatState:enter(previous)
 	CombatArena:initialize(16, 16)
 
-	Terminal:initialize(Vector(
+	self.t = Terminal(cmds, Vector(
 		CombatArena.rectLocation.x + CombatArena.rectDimensions.x + MainFont:getWidth(' '),
 		love.graphics.getHeight() - MainFont:getHeight()
 	))
 end
 
+function CombatState:leave()
+	Player = nil
+end
+
 function CombatState:update(dt)
 	CombatArena:update(dt)
 end
 
 function CombatState:draw()
-	Terminal:draw()
+	self.t:draw()
 	CombatArena:draw()
 end
 
 function CombatState:textinput(key)
-	Terminal:textinput(key)
+	self.t:textinput(key)
 end
 
 function CombatState:keypressed(key)
-	Terminal:keypressed(key)
+	self.t:keypressed(key)
 end
 
 return CombatState
diff --git a/CommandProcessor.lua b/CommandProcessor.lua
index c0e167a..e8f45a4 100644
--- a/CommandProcessor.lua
+++ b/CommandProcessor.lua
@@ -40,7 +40,7 @@ Signal.register('tty_stdin', function(input)
 	
 	for i,richCommand in ipairs(richInput) do
 		if richCommand.command then
-			local cmdObject = commands[richCommand.command]
+			local cmdObject = Commands[richCommand.command]
 			if cmdObject then
 				if cmdObject.isPlayer then
 					if Player then
diff --git a/LogonShell.lua b/LogonShell.lua
new file mode 100644
index 0000000..b1c089b
--- /dev/null
+++ b/LogonShell.lua
@@ -0,0 +1,39 @@
+-- main menu, more or less
+local Terminal = require 'Terminal'
+local CombatState = require 'CombatState'
+local Vector = require 'hump.vector'
+local Signal = require 'hump.signal'
+local Gamestate = require 'hump.gamestate'
+
+local LogonShell = {}
+
+local cmds = {
+	fight = {
+		name = 'fight',
+		actionFun = function() Gamestate.push(CombatState) end,
+		helpString = 'launch combat daemon'
+	},
+	exit = {
+		name = 'exit',
+		actionFun = function() love.event.quit() end,
+		helpString = 'exit application'
+	}
+}
+
+function LogonShell:enter(previous)
+	self.t = Terminal(cmds, Vector(5, love.graphics.getHeight() - 5), true)
+end
+
+function LogonShell:draw()
+	self.t:draw()
+end
+
+function LogonShell:textinput(key)
+	self.t:textinput(key)
+end
+
+function LogonShell:keypressed(key)
+	self.t:keypressed(key)
+end
+
+return LogonShell
diff --git a/Main.lua b/Main.lua
index 3903fea..a2ac7e9 100644
--- a/Main.lua
+++ b/Main.lua
@@ -1,8 +1,8 @@
 local Gamestate = require 'hump.gamestate'
 local Signal = require 'hump.signal'
 local Timer = require 'hump.timer'
-local CombatState = require 'CombatState'
 local Pause = require 'Pause'
+local LogonShell = require 'LogonShell'
 
 local function roundToNearest(value, rounder)
 	return math.floor(value / rounder) * rounder
@@ -13,7 +13,7 @@ function love.load()
 	local height = MainFont:getHeight()
 	love.window.setMode(roundToNearest(love.graphics.getWidth(), height), roundToNearest(love.graphics.getHeight(), height))
 	Gamestate.registerEvents()
-	Gamestate.switch(CombatState)
+	Gamestate.switch(LogonShell)
 end
 
 function love.update(dt)
diff --git a/Terminal.lua b/Terminal.lua
index 730d400..89ad5b9 100644
--- a/Terminal.lua
+++ b/Terminal.lua
@@ -1,9 +1,41 @@
 local utf8 = require 'utf8'
+local Class = require 'hump.class'
 local Signal = require 'hump.signal'
+local Vector = require 'hump.vector'
 local ScrollbackBuffer = require 'DataStructures.ScrollbackBuffer'
-require 'CommandProcessor'
 
-local Terminal = {}
+local Terminal = Class{}
+
+Terminal.baseCommands = {
+	help = {
+		name = 'help',
+		actionFun = function()
+			Signal.emit('tty_stdout', 'GriTTY version 1.37')
+			local order = {}
+			local maxLen = 0
+			for s, cmd in pairs(Terminal.baseCommands) do
+				table.insert(order, cmd)
+				maxLen = math.max(maxLen, #s)
+			end
+			for s, cmd in pairs(self.localCommands or {}) do
+				table.insert(order, cmd)
+				maxLen = math.max(maxLen, #s)
+			end
+			print(maxLen)
+			table.sort(order, function(a,b) return a.name < b.name end)
+			for i,c in ipairs(order) do
+				Signal.emit('tty_stdout', c.name..string.rep(' ', 4 + maxLen - #c.name)..c.helpString)
+			end
+		end,
+		helpString = 'print this message'
+	},
+
+	exit = {
+		name = 'exit',
+		actionFun = function() Gamestate.pop() end,
+		helpString = 'quit current application and return to previous'
+	}
+}
 
 -- returns the current input string split around the current cursor position
 -- if trim is true, it trims the left hand side by one character before returning
@@ -32,17 +64,16 @@ function Terminal:cursor_pixel_position(promptY)
 	local x, y = tmp % self.charsPerLine, math.floor(tmp / self.charsPerLine)
 
 	local charwidth = MainFont:getWidth(' ')
-	local base = self.x + charwidth / 2
+	local base = self.position.x + charwidth / 2
 
 	return base + x * charwidth + 1, promptY + y * MainFont:getHeight() 
 end
 
-function Terminal:initialize(position, echo)
+function Terminal:init(cmds, position, echo)
 	love.keyboard.setKeyRepeat(true)
 
 	-- position to print terminal line (including prompt)
-	self.x = position.x
-	self.y = position.y - MainFont:getHeight()
+	self.position = Vector(position.x, position.y - MainFont:getHeight())
 	
 	self.echo = echo
 	self.prompt = '> '
@@ -55,8 +86,91 @@ function Terminal:initialize(position, echo)
 	self.scrollback_out = ScrollbackBuffer(math.floor(love.graphics.getHeight() / MainFont:getHeight()))
 	self.scrollback_in = ScrollbackBuffer(self.scrollback_out.capacity)
 	
-	local alignLimit = love.graphics.getWidth() - self.x - MainFont:getWidth(' ') -- the space left for our terminal plus one character to look nice
+	local alignLimit = love.graphics.getWidth() - self.position.x - MainFont:getWidth(' ') -- the space left for our terminal plus one character to look nice
 	self.charsPerLine = math.floor(alignLimit / MainFont:getWidth(' '))
+
+	self.localCommands = cmds
+
+	self:setActive(true)
+end
+
+local function parse(str)
+	local cmds = {}
+	
+	local i = 1
+	for command in (str..';'):gmatch('([^;]*);') do
+		cmds[i] = {}
+		cmds[i].args = {}
+		local first = true
+		for arg in command:gmatch('%w+') do
+			if first then
+				cmds[i].command = arg
+				first = false
+			else
+				table.insert(cmds[i].args, arg) end
+		end
+		i = i + 1
+	end
+
+	return cmds
+end
+
+function Terminal:execute(input)
+	if #input == 0 then return end
+	if Player and Player.acting then
+		Signal.emit('tty_stderr', 'user device is occupied!')
+		return
+	end
+
+	local richInput = parse(input)
+	
+	for i,richCommand in ipairs(richInput) do
+		if richCommand.command then
+			local cmdObject = self.localCommands[richCommand.command] or self.baseCommands[richCommand.command]
+			if cmdObject then
+				if cmdObject.isPlayer then
+					if Player then
+						Player:pushAction(cmdObject, richCommand.args)
+					else
+						Signal.emit('tty_stderr', 'user device not initializaed')
+					end
+				else
+					cmdObject.actionFun(richCommand.args)
+				end
+			else
+				Signal.emit('tty_stderr', 'command \''..richCommand.command..'\' not recognized')
+			end
+		end
+	end
+end
+
+function Terminal:move(position)
+	self.position = position
+end
+
+function Terminal:setActive(state)
+	if state == self.active then return end
+	self.active = state
+	if state then
+		self.in_handle = Signal.register('tty_stdin', function(input)
+			if (self.echo) then
+				self.scrollback_out:add({self.prompt..input, {255, 255, 255}})
+			end
+			self:execute(input)
+		end)
+		
+		self.out_handle = Signal.register('tty_stdout', function(output)
+			self.scrollback_out:add({output, {255, 255, 255}})
+		end)
+		
+		self.err_handle = Signal.register('tty_stderr', function(output)
+			self.scrollback_out:add({output, {255, 0, 0}})
+		end)
+	else
+		Signal.remove('tty_stdin', self.in_handle)
+		Signal.remove('tty_stdout', self.out_handle)
+		Signal.remove('tty_stderr', self.err_handle)
+	end
 end
 
 -- basic text input
@@ -130,13 +244,13 @@ end
 function Terminal:draw()
 	-- current input
 	-- promptY: y value of the line of text with the prompt
-	local promptY = printMultiLine(self.prompt..self.input, self.charsPerLine, self.x, self.y)
+	local promptY = printMultiLine(self.prompt..self.input, self.charsPerLine, self.position.x, self.position.y)
 
 	-- previous output
 	local loopy = promptY - MainFont:getHeight()
 	for coloredtext in self.scrollback_out:iterator() do
 		love.graphics.setColor(coloredtext[2])
-		loopy = printMultiLine(coloredtext[1], self.charsPerLine, self.x, loopy) - MainFont:getHeight()
+		loopy = printMultiLine(coloredtext[1], self.charsPerLine, self.position.x, loopy) - MainFont:getHeight()
 	end
 	love.graphics.setColor(255,255,255,255)
 	
@@ -144,18 +258,4 @@ function Terminal:draw()
 	love.graphics.print(self.cursor_char, self:cursor_pixel_position(promptY))
 end
 
-Signal.register('tty_stdin', function(input)
-	if (Terminal.echo) then
-		Terminal.scrollback_out:add({Terminal.prompt..input, {255, 255, 255}})
-	end
-end)
-
-Signal.register('tty_stdout', function(output)
-	Terminal.scrollback_out:add({output, {255, 255, 255}})
-end)
-
-Signal.register('tty_stderr', function(output)
-	Terminal.scrollback_out:add({output, {255, 0, 0}})
-end)
-
 return Terminal
